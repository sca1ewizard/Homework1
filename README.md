# Homework1
___Домашнее задание №1 по предмету "Функциональная логика и теория алгоритмов".
Сорокин Сергей ИУ4-31Б Вариант 2.___
---------------------------------------------------------------------------
2. Пользователь вводит число в двоичной системе счисления, необходимо распечатать его в десятичной системе счисления.
Бонус: предусмотреть использование отрицательных чисел и возможность переполнения.
Пример ввода: 101
Пример вывода: 5
---------------------------------------------------------------------------
```c
#include <stdint.h>

#include <stdio.h>

#include <limits.h>

#include <stdlib.h>		       //подключаем все нужные нам библиотеки

//#pragma warning(disable: 4996);      //заглушаем предупреждения компилятора (в начале 
		                       //  программа использовала scanf и компилятор сильно ругался)

#define TRUE 1			       //используется для определения наличия у числа знака "+" или "-"
#define FALSE 0			       //используется для определения наличия у числа знака "+" или "-"
#define ERROR - 1		       //объявляем все макроподстановки

int main() {
	char buffer;	               //непосредственно введённый с клавиатуры символ
	unsigned int value = 0;	       //значение результата по модулю
	int count = 0;		       //подсчет символов результата (используется для определения переполнения) 
	int sign = FALSE;	           //переменная определяет какой знак у числа (0 если минус и 1 если плюс)
	if ((((buffer = getchar()) != EOF) && buffer != '\n' && buffer != '\0' && buffer == '-') && sign == FALSE) {
		sign = TRUE;	//если введенный сивол не конец файла и не символ перехода на новую строку и не символ конца строки
		while (((buffer = getchar()) != EOF) && buffer != '\n' && buffer != '\0') { // и символ это минус то берем всл. элемент 
		                                                                            //  с клавиатуры и меняем переменную sign
			
			if ((buffer == '1') || (buffer == '0')) {  //в двоичной записи числа содержаться только числа 1 и 0, так что для них...
				value <<= 1;	                   //сдвигаем побитово value на 1 бит влево
				value += buffer - '0';	           //и прибавляем к нему значение буфера
				count++;			   //инкриминируем счётчик символов
			}
			else {	//иначе, если символ не 1 или 0, значит символ введён неправильно и надо выдать ошибку
				printf("Error.\n");    //печатаем ошибку
				exit(ERROR);	       //завершаем программу с кодом ошибки -1
			}
		}
	}
	else {	 // иначе, берем уже взятый символ в первом getchar т.к. в безнаковом числе первый символ - цифра
		while ((buffer != EOF) && buffer != '\n' && buffer != '\0') {  //и проводим всё те же действия, что и со знаковым
			if ((buffer == '1') || (buffer == '0')) {
				value <<= 1;
				value += buffer - '0';
				count++;
			}
			else {
				printf("Error.\n");
				exit(ERROR);
			}
			buffer = getchar();
		}
	}
	if (count > sizeof(int) * CHAR_BIT) {    //Проверка не переполнение
		printf("Error oversize.\n");     //если количество символов больше чем 
		                                 //  максимально количество бит для данной архитектуры памяти, то выводим ошибку
		exit(ERROR);
	}
	if (sign == TRUE) {	//если есть знак "-", то печатаем его
		printf("-");
	}
	printf("%u\n", value);  //выводим результат
	return 0;
}
//00000000000000000000000000000000	 //Просто проверял по этим числам перепонение, чтобы каждый раз не вбивать 32 единицы
//11111111111111111111111111111111   
```
___СБОРКА___

Файл проекта Homework1.sln запускается на visual studio 2019

__Объяснение алгоритма:__

Первая цифра числа вводится с клавиатуры, и заносится в buffer через функцию getchar и проверяются условия существования символов, также проверяется наличие знака

Если этот знак есть, то программа забирает еще одну цифру и если эта цифра 1 или 0, сдвигает value побитово на 1 вправо и прибавляет элемент буфера и кол. символом числа

Иначе вылетает ошибка.

Тоже самое происходит, если в начале не выполнилось условие и знака нет. Отличие в том, что мы берем за первый символ значение buffer, уже найденное при проверке на знак (потому что у беззнакового числа первая цифра логично =) ).Далее проводим все те же операции.

Проверяем на переполнение.

Если присутствует знак - выводим его.

Выводим само число.

